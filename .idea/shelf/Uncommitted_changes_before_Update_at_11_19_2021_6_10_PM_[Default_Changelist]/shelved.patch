Index: classes.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from numpy.core.numeric import NaN\r\nimport pandas as pd\r\nimport numpy as np\r\n\r\nclass Graph:\r\n    # default Attributes ------------------------------------\r\n    ## meta-data\r\n    name = \"\"\r\n    date = \"\"\r\n    description = \"\"\r\n    ## bools\r\n    isMultiGraph = False\r\n    isDirected = False\r\n    isWeighted = False\r\n    ## data structures\r\n    adjacencyLists = {} # a dictionary - each key's value is a set of lists - first element in each list is the destination node name, second element is a numpy array of weights\r\n    adjacencyMatrix = pd.DataFrame()\r\n\r\n    # Methods -----------------------------------------\r\n    def __init__(self, file): #this will read files directly\r\n        f = open(file)\r\n        self.name = f.readline()[len(\"GraphName: \"):].split(\"\\n\")[0]\r\n        self.date = f.readline()[len(\"Date: \"):].split(\"\\n\")[0]\r\n        self.description = f.readline()[len(\"Description: \"):].split(\"\\n\")[0]\r\n        self.isMultiGraph = True if f.readline()[len(\"MultiGraph: \"):] == \"T\\n\" else False\r\n        self.isDirected = True if f.readline()[len(\"Directed: \"):] == \"T\\n\" else False\r\n        self.isWeighted = True if f.readline()[len(\"Weighted: \"):] == \"T\\n\" else False\r\n        #handle adjacencyList\r\n        sDict = {}\r\n        sourceNode1 = \"\"\r\n        for eachRow in f: #example of eachRow \"A -> B 1 2, D 2\\n\"\r\n            if(\"\\n\"==eachRow[len(eachRow)-1:]): #if the line ends in \"\\n\", then remove it - example result: \"A -> B 1 2, D 2\"\r\n                row = eachRow[:len(eachRow)-1]\r\n            else: row = eachRow #otherwise do just get the line as is\r\n            row = row.split(\"->\") #element 0 is source node, element 2 is destination nodes and associated weights - example result: [\"A \", \" B 1 2, D 2\"]\r\n            row[0]=row[0].split(\" \") #isolate source node's name from the space - example result: [\"A\",\"\"]\r\n            row[1]=row[1].split(\",\") #split destination nodes - example result: [\" B 1 2\",\" D 2\"]\r\n            for i in range(len(row[1])): #split destination nodes up from their weights - example of result:[[\"\",\"B\",\"1\",\"2\"],[\"\",\"D\",\"2\"]]]\r\n                row[1][i] = row[1][i].split(\" \")\r\n            #row = [['A', ''], [['', 'B', '1', '2'], ['', 'D', '2']]]\r\n            sourceNode = row[0][0]\r\n            self.addNode(sourceNode) #adds sourceNode to adjacencyList and adjacencyMatrix\r\n            destinationNodes = row[1]\r\n            for dest in destinationNodes: #removes the empty string so we are left with just node names and weights\r\n                dest = dest[1:]\r\n                destination = dest[0]\r\n                if (self.isWeighted):\r\n                    weights = dest[1:]\r\n                if (sourceNode1 == sourceNode):\r\n                    sDict[\"\"] = [destination, weights]\r\n                else:\r\n                    sDict[sourceNode] = [destination, weights]\r\n                sourceNode1 = sourceNode\r\n                print(dest)\r\n                #destinationNodes = [['B', '1', '2'], ['D', '2']]\r\n        print(sDict)\r\n\r\n\r\n    def addNodeToAdjacencyMatrix(self, df, node):\r\n        df.insert(loc=len(df.columns), column=node, value= NaN)\r\n        newRow = pd.Series(name=node, dtype='object')\r\n        return df.append(newRow)\r\n\r\n    def addNode(self, node):\r\n        if(None == self.adjacencyLists.get(node)):\r\n            self.adjacencyLists.update({node:{} })\r\n            self.adjacencyMatrix = self.addNodeToAdjacencyMatrix(self.adjacencyMatrix, node)\r\n    \r\n    def addEdges(self, source, destArray): #doesn't matter if it's directed or not, does matter if it's weighted\r\n        destination = destArray[0]\r\n        if(self.isWeighted):\r\n            weights = destArray[1:]\r\n        self.addNode(source) #if the node is already in adjacencyLists then this will do nothing. We have this line for when this function is used later on\r\n\r\n        #do adjacencyList first\r\n        #first check if destination is in source's set\r\n        if destination in self.adjacencyLists.get(source): #if the destination is already in \r\n\r\n\r\n\r\n\r\nclass GraphCollection:\r\n    def __init__(self, file):\r\n        f = open(file)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/classes.py b/classes.py
--- a/classes.py	(revision 88ccb9b921b6d61f676e2b250753051a9fa2e76c)
+++ b/classes.py	(date 1637278914831)
@@ -74,7 +74,7 @@
 
         #do adjacencyList first
         #first check if destination is in source's set
-        if destination in self.adjacencyLists.get(source): #if the destination is already in 
+        #if destination in self.adjacencyLists.get(source): #if the destination is already in 
 
 
 
